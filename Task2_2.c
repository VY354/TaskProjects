//Подключаем стандаотную библтотеку ввода и вывода
#include <stdio.h>
//Подключаем математическую библиотеку для использования математических функций
#include <math.h>
//Подключаем библиотеку для использования типа данных Bool
#include <stdbool.h>
//Подключаем стандартную библиотеку для использования команды clear
#include <stdlib.h>
//Прототип функции для поиска корня
void FindRoot(float[],float,float,float,int,int);
//Прототип функции для вичисления производной в точке
float CulcDerivative(float,float,float,int);
//Прототип функции для вычисления значения функции в точке
float CulcExpr(float,float,float,int);
//Прототип функции для проверки знаков функции на концах отрезка [ x_n-pow(10,-accr) ; x_n1+pow(10,-accr) ]
_Bool CheckSign(float,float,float,float,int,int);
//Главная функция main
int main(){
	//Очистка экрана перед началом работы
	system("clear");
	//Объявляем переменную для определения точности рассчета и выбора номера функции
	int accr,choose;
	//Объявляем коэффициенты a,b и переменную для начальной точки отсчета
	float a,b,x_n,Answer[2];
	//Просим пользователя выбрать уравнение
	printf("Choose equation:\n");
	printf("------------------------------------------\n");
	//Выводим на экран 1 уравнение
	printf("1: Y = log2(ax)-b\n");
	//Выводим на экран 2 уравнение
	printf("2: Y = x^4+ax^3-bx\n");
	//Выводим на экран 3 уравнение
	printf("3: Y = x^5+ax^2-b\n");
	//Выводим на экран 4 уравнение
	printf("4: Y = ax+b\n");
	//Выводим на экран 5 уравнение
	printf("5: Y = a*x^3+b\n");
	//Выводим на экран 6 уравнение
	printf("6: Y = a/(1+e^(-x+b))-0.5\n");
	printf("------------------------------------------\n");
	//Просим ввсети номер уравнения
	printf("Enter number of equation          : "); scanf("%d",&choose);
	//Проверяем наличие уравнения в списке
	while(choose<1 || choose>6){
		//Просим повторно ввести номер уравнения, если выбран номер меньше 1 или больше 6
		printf("There is no equation with this number. Please, enter correct number: "); scanf("%d",&choose);
	}
	//Просим ввсети параметр а
	printf("Enter value of parameter a        : "); scanf("%f",&a);	
	//Если выбрали 1 уравнение
	if(choose==1){
		//Доп. условие для логарифма а*х >0
		while(a<=0){
			//Просим повторно ввести значение
			printf("Incorrect data. Please, enter other value of a ( a>0 ): "); scanf("%f",&a);
		}
	}
	//Просим ввести значение параметра b
	printf("Enter value of parameter b        : "); scanf("%f",&b);
	//Просим ввести точность (количество знаков после запятой)
	printf("Enter accuracy (signs after comma): "); scanf("%d",&accr);
	//Просим ввести начальную точку отсчета
	printf("Enter start point( x )            : "); scanf("%f",&x_n);
	//Если выбрали 1 уравнение
	if(choose==1){
		//Доп. условие для логарифма (ОДЗ: [0;+inf])
		while(x_n<=0){
			//Просим повторно ввести значение параметра b
			printf("Incorrect data. Please, enter other value of x ( x>=0 ): "); scanf("%f",&x_n);
		}
	}
	//Вызываем функцию нахождения корня
	FindRoot(Answer,a,b,x_n,accr,choose);
	printf("------------------------------------------\n");
	//Вывод на экрам ответа
	//вывод значения х, при котором у=0 и необходимого количества итераций
	printf("Y ~ 0 when x = %.10f\n",Answer[0]);
	printf("Iterations need: %d\n",(int)Answer[1]);
	//так как функция main типа int, то она должна что-то возвращать
	return 0;
}
//Реализация функции для нахождения корня
void FindRoot(float Answer[], float a,float b,float x_n,int accr,int choose){
	//Задаем счетчик максимального количества итераций (static, чтобы 
	//по выхлду из функции значение сохранялось)
	static int i,count=0;
	//Задаем переменные для хранения точки пересечения касательной а осью Ох, 
	//значения выражения и значения производной
	float x_n_additional,x_n1=0,expr,der;
	//Запоминаем текущий x_n, так как в строчке 98 x_n становится 
	//равным x_n1 и их разность соответственно 0.
	x_n_additional=x_n;
	//цикл для контроля количества итераций
	while(fabs(x_n_additional-x_n1)>pow(10,-accr)){
		//увеличиваем счетчик итераций на 1
		count++;
		//Запоминаем текущий x_n, так как в строчке 98 x_n становится 
		//равным x_n1 и их разность соответственно 0.
		x_n_additional=x_n;
		//Проверка количества итераций
		if(i>200){
			//говорим. что произошла ошибка и не возножно определить корень
			printf("ERROR: can not define root.\n");
			//выводим последнее значение корня
			printf("Last value is: %-10.10f\n",x_n1);
			//прерываем цикл
			break;
		}
		//Вычисляем точку пересечения касательной с осью Ох
		x_n1=x_n-CulcExpr(a,b,x_n,choose)/CulcDerivative(a,b,x_n,choose);
		//Устанавливаем эту точку как начальную.
		x_n=x_n1;
		//увеличиваем счетчик итерации на 1.
		i++;
	}
	//вызываем функцию для проверки знаков на отрезке 
	//[ x_n-pow(10,-accr) ; x_n1+pow(10,-accr) ]
	if(CheckSign(a,b,x_n,x_n1,accr,choose))
		//Если возвращается 1, то продолжаем вычисления с тчностью, 
		//увеличенной на 1 порядок
		FindRoot(Answer,a,b,x_n1,accr+1,choose);
	//Если CheckSign возвращает 0, то завершаем программу 
	//и записываем ответ и количество итераций в массив
	Answer[0]=x_n1;
	Answer[1]=count;
}
//Реализация функции для вычисления значения выражения в точке
float CulcExpr(float a,float b,float x_n,int choose){
	//объявляем переменную для хранения значения выражения
	float expr;
	//Считаем значение функции в точке исходя из выбранного уравнения
	switch(choose){
		//Если выбрали 1
		case(1):{
			//Считаем значение функции в точке
			expr=log2(a*x_n)-b;
			//Прерываем оператор
			break;
		}
		//Если выбрали 2
		case(2):{
			//Считаем значение функции в точке
			expr=powf(x_n,4)+a*powf(x_n,3)-b*x_n;
			//Прерываем оператор
			break;
		}
		//Если выбрали 3
		case(3):{
			//Считаем значение функции в точке
			expr=powf(x_n,5)+a*powf(x_n,2)-b;
			//Прерываем оператор
			break;
		}
		//Если выбрали 4
		case(4):{
			//Считаем значение функции в точке
			expr=a*x_n+b;
			//Прерываем оператор
			break;
		}
		//Если выбрали 5
		case(5):{
			//Считаем значение функции в точке
			expr=a*powf(x_n,3)+b;
			//Прерываем оператор
			break;
		}
		//Если выбрали 6
		case(6):{
			//Считаем значение функции в точке
			expr=a/(1+exp(-x_n+b))-0.5;
			//Прерываем оператор
			break;
		}
	}
	//Возвращаем значение функции
	return expr;
}
//Реализация функции для вычисления значения производной в точке
float CulcDerivative(float a,float b,float x_n,int choose){
	//Объявляем переменную для хранения значения производной в точке
	float der;
	//Считаем значение производной в точке исходя из выбранного уравнения
	switch(choose){
		//Если выбрали 1
		case(1):{
			//Считаем значение производной в точке
			der=1/(x_n*log(2));
			//Прерываем оператор
			break;
		}
		//Если выбрали 2
		case(2):{
			//Считаем значение производной в точке
			der=powf(x_n,2)*(3*a+4*x_n)-b;
			break;
		}
		//Если выбрали 3
		case(3):{
			//Считаем значение производной в точке
			der=2*a*x_n+5*powf(x_n,4);
			//Прерываем оператор
			break;
		}
		//Если выбрали 4
		case(4):{
			//Считаем значение производной в точке
			der=a;
			//Прерываем оператор
			break;
		}
		//Если выбрали 5
		case(5):{
			//Считаем значение производной в точке
			der=3*a*powf(x_n,2);
			//Прерываем оператор
			break;
		}
		//Если выбрали 6
		case(6):{
			//Считаем значение производной в точке
			der=(a*exp(b+x_n))/powf(exp(b)+exp(x_n),2);
			//Прерываем оператор
			break;
		}
	}
	//Возвращаем значение производной
	return der;
}
//Реализация функции для проверки знаков функции на краях 
//отрезка [ x_n-pow(10,-accr) ; x_n1+pow(10,-accr) ]
_Bool CheckSign(float a,float b,float x_n,float x_n1,int accr,int choose){
	//Объявляем переменные для хранения значения функции 
	//на концах отрезка [ x_n-pow(10,-accr) ; x_n1+pow(10,-accr) ]
	float LeftExpr,RightExpr;
	//Считаем значение функции на левой границе
	LeftExpr=CulcExpr(a,b,x_n1-pow(10,-accr),choose);
	//Считаем значение функции на правой границе
	RightExpr=CulcExpr(a,b,x_n1+pow(10,-accr),choose);
	//Проверяем не имеют ли они одинаковый знак
	if((LeftExpr>0 && RightExpr>0)||(LeftExpr<0 && RightExpr<0)) 
		//если однаковый знак то возвращаем истину
		return true;
		//иначе ложь
	else
		return false;
}